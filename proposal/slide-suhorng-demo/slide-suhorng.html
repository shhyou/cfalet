<!DOCTYPE html>
<html class="remark-container"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>2014 Sprout 15 - Next Step</title>
    <link rel="stylesheet" href="./style2.css">
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;delayStartupUntil=configured" type="text/javascript"></script>
  </head>
  <body class="remark-container">
    <textarea id="source" style="display: none;">name: inverse
class: title, inverse, center, middle
# Locally Relax the Value Restriction by Control Flow Analysis
---
# Abstract

This project is aiming at relaxing the value restriction locally via flow analysis, where the value striction has long been the standard yet too restrictive solution to integrating Hindler-Milner style polymorphism with imperative features.

<!--
The value restriction has long been adopted as the standard solution to integrating Hindley-Milner style polymorphism with imperative features, yet the value restriction is too conservative in rejecting to generalize all non-value terms. In this project
we shall aim at relaxing the value restriction locally via control flow analysis.
-->

![expressiveness](./expressiveness.png)

---
# Motivation
- The value restriction refuses to generalize all non-value terms, hence rejecting procedures that compute polymorphic functions, e.g. the combinators.

    * Also rejects polymorphic data structures

- Use of imperative features are rare; most of the computation are functionally pure.

---
# Challenges

- The value restriction is actually at a balance point that any extension could probably be unwillingly complex and break the module abstraction.

- Polymorphism has a bad interaction with imperative features such as mutable variable.

    ```javascript
    var mem = (function unsound() {
      var mem = null;
      return function(x) {
        if (mem === null) {
          mem = x;
          return x;
        } else {
          var y = mem;
          mem = x;
          return y;
        }
      };
    })();

    var mem = unsound();  /* mem : forall a. a -> a */
    var s = mem("hello"); /* mem "hello"  :  string */
    var n = 3 + mem(5);   /* disaster: adding number and string */
    ```

<!--
    ```ocaml
    fun unsound () =
      let val mem = ref NONE
      in  fn x => case !mem of
            NONE   => (mem := SOME x; x)
          | SOME y => (mem := SOME x; y)
      end

    val mem = unsound ()
    val s = mem "hello"
    val n = 3 + mem 5
    ```
-->

---
# Potential Solutions
</textarea>
    <script src="./remark-0.6.0.min.js" type="text/javascript"></script>
    <script src="./highlight.pack.js"></script>
    <script type="text/javascript">
      /* override default hljs engine to provide Haskell syntax highlight */
      remark.highlighter.engine = hljs;
      var slideshow = remark.create({
        highlightStyle: 'ir_black'
      });
      MathJax.Hub.Config({
        "HTML-CSS": { scale: 75 },
        tex2jax: {
          skipTags: ['code', 'script', 'noscript', 'style' ,'textarea', 'pre'],
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['\\[', '\\]']]
        }
      });
      MathJax.Hub.Configured();
    </script>
    <div class="remark-notes-area">hello world</div>
</body></html>
